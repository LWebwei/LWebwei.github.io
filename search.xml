<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大区间素数筛选]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%A4%A7%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%2F</url>
    <content type="text"><![CDATA[大区间素数筛选： 筛两次，第一次筛出1到1000000的素数，因为1000000^2已经超出int范围，这样的素数足够了。函数getPrim()； prime[ ] 存第一次筛出的素数，总个数为prime[0]第二次利用已经筛出的素数去筛L,R之间的素数函数getPrime2(); isprime[] 判断该数是否为素数 prime2[ ]筛出的素数有哪些，一共有prime2[0]个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int maxn=1e6;int prime[maxn+10];int ans ;void getPrime()&#123; memset(prime,0,sizeof(prime));//一开始prime都设为0代表都是素数（反向思考） for(int i=2;i&lt;=maxn;i++) &#123; if(!prime[i]) prime[++prime[0]]=i; for(int j=1;j&lt;=prime[0]&amp;&amp;prime[j]&lt;=maxn/i;j++) &#123; prime[prime[j]*i]=1;//prime[k]=1；k不是素数 if(i%prime[j]==0) break; &#125; &#125;&#125;bool isprime[maxn+10];int prime2[maxn+10];int getPrime2(int L,int R)&#123; ans = 0; memset(isprime,1,sizeof(isprime)); //isprime[0]=isprime[1]=0;//这句话不能加，考虑到左区间为2的时候，加上这一句，素数2,3会被判成合数 if(L&lt;2) L=2; for(int i=1;i&lt;=prime[0]&amp;&amp;(long long)prime[i]*prime[i]&lt;=R;i++) &#123; int s=L/prime[i]+(L%prime[i]&gt;0);//计算第一个比L大且能被prime[i]整除的数是prime[i]的几倍,从此处开始筛 if(s==1)//很特殊,如果从1开始筛的话，那么2会被筛成非素数 s=2; for(int j=s;(long long)j*prime[i]&lt;=R;j++) if((long long)j*prime[i]&gt;=L) isprime[j*prime[i]-L]=false; //区间映射 &#125; prime2[0]=0; for(int i=0;i&lt;=R-L;i++)&#123; if(isprime[i])&#123; prime2[++prime2[0]]=i+L; ans++; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>acm模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数模板]]></title>
    <url>%2F2017%2F08%2F04%2F%E7%BB%84%E5%90%88%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[组合数打表： 12345678910int C[33][33];void init()&#123; C[0][0]=C[1][0]=C[1][1]=1; for(int i=2;i&lt;33;i++)&#123; C[i][0]=1; for(int j=1;j&lt;i;j++) C[i][j]=C[i-1][j-1] + C[i-1][j]; C[i][i]=1; &#125;&#125;]]></content>
      <categories>
        <category>acm模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长递增子序列]]></title>
    <url>%2F2017%2F07%2F25%2F%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长递增子序列： 12345678910111213141516171819202122#define inf 0x3f3f3f3fint num[50000+11];int num2[50000+11];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); fill(num2,num2+n+10,inf); num2[0]=-inf; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;num[i]); int ans=1; for(int i=1;i&lt;=n;++i) &#123; int pos=upper_bound(num2,num2+n+10,num[i])-num2; num2[pos]=num[i]; if(pos&gt;ans) ans=pos; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>acm模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂]]></title>
    <url>%2F2017%2F07%2F25%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[矩阵快速幂： 123456789101112ll PowerMod(ll a,ll b) &#123; int ans=1; a=a%mod; while(b&gt;0) &#123; if(b%2==1) ans=(ans*a)%mod; b=b/2; a=(a*a)%mod; &#125; return ans; &#125;]]></content>
      <categories>
        <category>acm模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算技巧题]]></title>
    <url>%2F2017%2F07%2F25%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[异或： 题目链接：http://codeforces.com/contest/484/problem/A 题目大意：给定区间l，r，找到一个数x，保证x在区间上，并且要求x的bitcount尽量大的前提下数值尽量小。 解题思路：默认x为全1的二进制数，每次从最高为判断，看最高位的1变为0后大于r，就将该为变成0；落在区间上则即 为要照的答案；小于l则表示该为不能为0. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;ll n,l, r,ans;int main()&#123; while(cin&gt;&gt;n)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;l&gt;&gt;r; ans=(1LL&lt;&lt;62)-1; for(int i=61;i&gt;=0;i--)&#123; if(r&gt;=ans&amp;&amp;ans&gt;=l) break; if((ans^(1LL&lt;&lt;i))&lt;l) continue; ans^=(1LL&lt;&lt;i); &#125; cout&lt;&lt;ans&lt;&lt;&apos;\n&apos;; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法]]></title>
    <url>%2F2017%2F06%2F18%2F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[矩阵乘法： 123456789101112131415/* 假设 A 是 m*p 的矩阵 , B 是 p*n 的矩阵 记 C = AB (C 是 矩阵 A与B的乘积) 那么 C 是 m*n 的矩阵 */ for (int i = 1;i &lt;= m;++i)//A的行 &#123; for (int j = 1;j &lt;= n;++j)//B的列 &#123; for (int k = 1;k &lt;= p;++k)//通过公式求C &#123; C[i][j] += A[i][k]*B[k][j]; &#125; &#125; &#125;]]></content>
      <categories>
        <category>acm模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces#264总结]]></title>
    <url>%2F2017%2F05%2F11%2Fcodeforces-264%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[A：题目链接：http://codeforces.com/contest/463/problem/A题目大意：Caisa去超市买东西，有s美元，一美元等于100每分，现在给定n种商品的价格x美元y美分，超市找零是用糖果替代美分，一美分一颗糖果，Caisa想要尽量多的糖果。水题，直接遍历一遍就好 代码如下： 12345678910111213141516// &gt;File Name: cf#264A.cpp// &gt; Author: Webwei#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,s,ans=-1,x,y; cin&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(x&lt;s||(x==s&amp;&amp;y==0)) ans=max(ans,y==0?0:100-y); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B:题目链接：http://codeforces.com/contest/463/problem/B题目大意：给定n个位置的高度，0的位置为0，每次移动一步时，需要消耗hi−hi+1的能量，一开始能量为0，过程中能量不能为负，一美元可以买一点能量，问说最小开销。 这道题一般的思路就是边走边维护使能量不为负，但是大佬的做法直接看到了是求数列的最大值即可。大佬的代码： 12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main () &#123; int n, x, ans = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;x); ans = max(ans, x); &#125; printf(&quot;%d\n&quot;, ans); return 0;&#125; C：题目链接：http://codeforces.com/contest/463/problem/C题目大意： 在国际象棋的棋盘上放两个主教，这个两个主教不能攻击到同一个格子，最后的得分是这两个主教的攻击的格子上的分数之和。求最大的分数。（国际象棋规则主教的行走路线是斜着走）解题思路：因为攻击的范围是对角线，所以两个主教一个在黑格，一个在白格。画个图就可以发现一旦一个主教放在了黑格，那么剩下的黑格是都不能在放主教的，否则就是攻击到相同的格子。所以求出每条对角线的和，通过这个得出每个格子作为主教的得分，最后黑白格分开讨论。在求出每条对角线的和的时候的巧妙优化我觉得要好好借鉴学习一下。（另外cin没加优化的时候尽然超时了，gg）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll a[2005][2005];ll d1[4010],d2[4010];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int n; cin&gt;&gt;n; memset(d1,0,sizeof(d1)); memset(d2,0,sizeof(d2)); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;a[i][j]; d1[i+j]+=a[i][j]; d2[i-j+n]+=a[i][j]; &#125; &#125; ll odd = -1,even = -1; ll oddx,oddy,evenx,eveny; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if((i+j)&amp;1)&#123; if(odd&lt;d1[i+j]+d2[i-j+n]-a[i][j])&#123; odd=d1[i+j]+d2[i-j+n]-a[i][j]; oddx=i; oddy=j; &#125; &#125; else&#123; if(even&lt;d1[i+j]+d2[i-j+n]-a[i][j])&#123; even=d1[i+j]+d2[i-j+n]-a[i][j]; evenx=i; eveny=j; &#125; &#125; &#125; &#125; cout&lt;&lt;odd+even&lt;&lt;&apos;\n&apos;&lt;&lt;oddx&lt;&lt;&quot; &quot;&lt;&lt;oddy&lt;&lt;&quot; &quot;&lt;&lt;evenx&lt;&lt;&quot; &quot;&lt;&lt;eveny&lt;&lt;&apos;\n&apos;; return 0;&#125; D；题目链接：http://codeforces.com/contest/463/problem/D题目大意：求k个序列的最长公共子序列。 首先求两个序列的最长公共子序列就是基础的dp这里类比在总结一下两个序列的最长公共子序列两个串的话LCS(x,y) =(1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By(3) 0 如果x = 0或者y = 0如果要输出最长公共子序列的话加上标记就好了。先贴一下这个的代码：输入：abcicbaabdkscab输出：abca代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char str1[1010];char str2[1010];int dp[1010][1010];int flag[1010][1010];char str3[1010];int main()&#123; scanf(&quot;%s%s&quot;, str1, str2); memset(dp, 0, sizeof(dp)); memset(flag, 0, sizeof(flag)); int i, j; int len1 = strlen(str1); int len2 = strlen(str2); for (i = 1; i &lt;= len1; i++) for (j = 1; j &lt;= len2; j++) &#123; if (str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; flag[i][j] = 1; &#125; else &#123; dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); if (dp[i][j] == dp[i][j - 1]) flag[i][j] = 2; else if (dp[i][j] == dp[i - 1][j]) flag[i][j] = 3; &#125; &#125; int m = 0; while (len1&gt;0 &amp;&amp; len2&gt;0) &#123; if (flag[len1][len2] == 1) &#123; str3[m++] = str1[len1 - 1]; len1--; len2--; &#125; else if (flag[len1][len2] == 2) len2--; else if (flag[len1][len2] == 3) len1--; &#125; for (i = m - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, str3[i]); printf(&quot;\n&quot;);&#125; 接下来回到D题，这个题应该也是dp，但是要怎么dp呢。看代码解释吧： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n,k; int position[5][1000];//记录position[i][j]记录第i行中，数字j出现的位置。 int a[5][1000];//记录数列 int dp[1000];//dp[i]表示，以下标i结尾的最长公共子序列长度。 int main(void) &#123; while(cin&gt;&gt;n&gt;&gt;k)&#123; for(int i=0;i&lt;k;i++)&#123; for(int j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); position[i][--a[i][j]]=j; &#125; &#125; int ans=0; for(int j=0;j&lt;n;++j)&#123;//对于 j int maxn=0; for(int p=0;p &lt;j;++p)&#123;//对于 以（j之前的每个点） 结尾的最长序列，判断j可不可以加进去 int i; for(i=1;i&lt;k&amp;&amp;position[i][a[0][p]]&lt;position[i][a[0][j]];++i) ; if(i==k&amp;&amp;dp[p]&gt;maxn)&#123;//求这些可以加进去的点中，dp值最大的一个 maxn=dp[p];// &#125; &#125; dp[j]=maxn+1;//本点dp值=最大dp值加上1 ans=max(ans,dp[j]);//求每一点dp值最大的一个。 &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0; &#125; &lt;深刻领悟，不断进步&gt;]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水题优化（持续更新）]]></title>
    <url>%2F2017%2F05%2F06%2F%E6%B0%B4%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[（这篇文章会持续不断的更新补题）题目链接：http://codeforces.com/contest/496/problem/A题目大意 : 给出有 n 个数的序列，然后通过删除除了第一个数和最后一个数的任意一个位置的数，求出删除这个数之后序列的最大相邻差是多少，然后删除下一个数，继续求出最大相邻差，直到删到倒数第二个数，最后从这些最大相邻差中找出最小的那个输出。例如：有序列为1 2 3 7 8，删除第二个、第三个、第四个数后得到的序列分别为：(1, 3, 7, 8)， (1, 2, 7, 8)， (1, 2, 3, 8)。那么最大相邻差分别为 4,5,5，选出最小的那个就是答案 4 。 这个题给的范围是n在100以内，所以可以直接暴力来搞，复杂度 O(n^2) ，这种做法应该都会。 但是如果n在1e5又该怎么办？这里就说一下这个优化，就是统计相邻的最大的，和隔开的两个数的最小的，这两者取最大值就好了，算法复杂度为 2*O(n);从而达到了优化代码如下： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int a[100010]; int main()&#123; int n; cin&gt;&gt;n; int ans=0; int temp=0x3f3f3f3f; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;n;i++) ans=max(ans,a[i+1]-a[i]); for(int i=2;i&lt;n;i++) temp=min(temp,a[i+1]-a[i-1]); cout&lt;&lt;max(temp,ans)&lt;&lt;endl; return 0;&#125; 题目链接：http://codeforces.com/problemset/problem/363/B题目大意：找n个数中连续k个数的和最小 这个题也不叫优化吧，但是想放在这里，就是如果n小的话就可以用暴力直接解决了，但是这个n是比较大的，当时没有想到，其实只要遍历找一次就好了用sum[0]保存a[0]到a[k-1]项的和，那么sum[1]就可以表示为sum[0]-a[0]+a[k]，以此类推。把时间复杂度降到了O(n)；代码如下： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int a[500010];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int n,k; cin&gt;&gt;n&gt;&gt;k; int sum=0,ans=0; int jg=1; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=k;i++) sum+=a[i]; ans=sum; for(int i=k+1;i&lt;=n;i++)&#123; sum=sum+a[i]-a[i-k]; if(sum&lt;ans) ans=sum,jg=i-k+1; &#125; cout&lt;&lt;jg&lt;&lt;&apos;\n&apos;; return 0;&#125;]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>水题之优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客有感]]></title>
    <url>%2F2017%2F04%2F29%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[首先要感谢这两篇文章，一个是hexo+GitHub 搭建博客教程，一个是hexo next主题的配置。链接1：http://opiece.me/2015/04/09/hexo-guide/链接2：http://blog.csdn.net/zuoziji416/article/details/53204478 我主要说一下在搭建博客的时候遇到的问题。首先那个命令 hexo d,没有结果，到后来的时候百度问题，发现有个人说要先设置git身份信息 12&gt; $ git config --global user.name &quot;你的用户名&quot;&gt; $ git config --global user.email &quot;你的邮箱&quot; 然后这样发布博客或者更改配置的时候 hexo d 就可以了。然后就是next 主题设置，由于多说评论今年6月1号的时候就要关停服务了，所以没有再加入评论功能。然后上面教程是用的百度站长统计访问量，我发现用这个更加简洁方便一点 LeanCloud。这个可以搜一下教程。 然后就基本没有什么了。那两个教程基本也都有了。注意有一个大坑！尽量不要用 hexo clean ！尽量不要用 hexo clean !尽量不要用 hexo clean ！重要的话说三次，每次一用这个，hexo d 就失效，就得按上面 重新设置身份信息。 蒽，总算搭好了自己的博客，感觉还不错！]]></content>
      <categories>
        <category>搭博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>